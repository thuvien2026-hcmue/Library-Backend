{"version":3,"file":"index.js","names":["file: AnyFile<TRoute>","file: File","file: PendingFile","rangeStart: number","file: UploadingFile","xhrResult: UploadPutResult","file: PendingFile | UploadingFile","reason: UploadThingClientError<TRoute[\"$types\"][\"errorShape\"]>","url: string","options: RequestPresignedUrlsOptions<TRouter, TEndpoint>","endpoint: TEndpoint","options: UploadFilesOptions<TRouter[TEndpoint]>","version","initOpts?: GenerateUploaderOptions","slug: EndpointArg<TRouter, TEndpoint>","options: Omit<\n      UploadFilesOptions<TRouter[TEndpoint]>,\n      keyof GenerateUploaderOptions\n    >","fetchFn: FetchEsque","file: PendingFile","presigned: NewPresignedUrl","UploadPausedError","file?: File","file","UploadAbortedError","file?: T","uploadFiles","opts: Omit<\n      UploadFilesOptions<TRouter[TEndpoint]>,\n      keyof GenerateUploaderOptions\n    >"],"sources":["../src/_internal/client-future.ts","../src/client-future.ts"],"sourcesContent":["import * as Arr from \"effect/Array\";\nimport type { LazyArg } from \"effect/Function\";\nimport * as Micro from \"effect/Micro\";\nimport * as Predicate from \"effect/Predicate\";\n\nimport { fetchEff } from \"@uploadthing/shared\";\nimport type {\n  FetchContext,\n  FetchError,\n  MaybePromise,\n  UploadAbortedError,\n} from \"@uploadthing/shared\";\n\nimport { version } from \"../../package.json\";\nimport type {\n  AnyFileRoute,\n  FileRouter as AnyFileRouter,\n  NewPresignedUrl,\n} from \"../types\";\nimport type { TraceHeaders } from \"./random-hex\";\nimport { generateTraceHeaders } from \"./random-hex\";\nimport type { UploadPutResult } from \"./types\";\nimport { createUTReporter } from \"./ut-reporter\";\n\n/**\n * Error indicating the XHR request failed\n * @public\n */\nexport class XHRError extends Micro.TaggedError(\"XHRError\")<{\n  message: string;\n  xhr: unknown;\n}> {}\n\n/**\n * Error indicating the network request failed\n * @public\n */\nexport type NetworkError = XHRError | FetchError;\n\n/**\n * Error indicating the upload was rejected during upload to the storage provider\n * @public\n */\nexport class UTStorageError extends Micro.TaggedError(\"UTStorageError\")<{\n  message: string;\n  response: unknown;\n}> {}\n\n/**\n * Error indicating the request to your UploadThing server failed\n * @public\n */\nexport class UTServerError<TErrorShape> extends Micro.TaggedError(\n  \"UTServerError\",\n)<{\n  message: string;\n  cause: unknown;\n  /**\n   * Matches the shape returned by your error formatter\n   */\n  data: TErrorShape;\n}> {}\n\n/**\n * Error indicating the upload failed\n * @public\n */\nexport type UploadThingClientError<TErrorShape> =\n  | UploadAbortedError\n  | NetworkError\n  | UTStorageError\n  | UTServerError<TErrorShape>;\n\n/**\n * A file that has not started uploading yet.\n * Can either be pending for the presigned request to resolve,\n * or pending for the browser to schedule the network request.\n * @public\n */\nexport interface PendingFile extends File {\n  status: \"pending\";\n  /**\n   * How many bytes of the file has been uploaded\n   * @example 0\n   */\n  sent: number;\n  /**\n   * The key of the file. Null before the presigned request resolves.\n   */\n  key: string | null;\n  /**\n   * The customId of the file. Null before the presigned request resolves, then present if your file route sets it\n   */\n  customId: string | null;\n}\n\n/**\n * A file that is currently uploading.\n * @public\n */\nexport interface UploadingFile extends File {\n  status: \"uploading\";\n  /**\n   * How many bytes of the file has been uploaded\n   * @example 2500\n   */\n  sent: number;\n  /**\n   * The key of the file.\n   */\n  key: string;\n  /**\n   * The customId of the file, if your file route sets it\n   */\n  customId: string | null;\n}\n\n/**\n * A file that failed to upload.\n * @public\n */\nexport interface FailedFile<TRoute extends AnyFileRoute> extends File {\n  status: \"failed\";\n  /**\n   * How many bytes of the file were uploaded before the upload failed.\n   * @example 2500\n   */\n  sent: number;\n  /**\n   * The key of the file.\n   */\n  key: string;\n  /**\n   * The customId of the file, if your file route sets it\n   */\n  customId: string | null;\n  /**\n   * The error that occurred during the upload.\n   */\n  reason: UploadThingClientError<TRoute[\"$types\"][\"errorShape\"]>;\n}\n\n/**\n * A file that has been uploaded successfully.\n * @public\n */\nexport interface UploadedFile<TRoute extends AnyFileRoute> extends File {\n  status: \"uploaded\";\n  /**\n   * How many bytes of the file has been uploaded.\n   * @example 10000\n   */\n  sent: number;\n  /**\n   * The key of the file.\n   */\n  key: string;\n  /**\n   * The customId of the file, if your file route sets it\n   */\n  customId: string | null;\n  /**\n   * The url of the file.\n   * @example \"https://APP_ID.ufs.sh/f/KEY\"\n   */\n  url: string;\n  /**\n   * The data returned by the serverside `onUploadComplete` callback.\n   * @example { uploadedBy: \"user_123\" }\n   */\n  data: TRoute[\"$types\"][\"output\"];\n  /**\n   * The hash ( <> checksum ) of the file.\n   */\n  hash: string;\n}\n\n/**\n * A web file with additional state properties\n * @public\n */\nexport type AnyFile<TFileRoute extends AnyFileRoute> =\n  | PendingFile\n  | UploadingFile\n  | FailedFile<TFileRoute>\n  | UploadedFile<TFileRoute>;\n\n/**\n * Predicate function to check if a file is pending\n * @public\n */\nexport function isPendingFile<TRoute extends AnyFileRoute = AnyFileRoute>(\n  file: AnyFile<TRoute>,\n): file is PendingFile {\n  return file.status === \"pending\";\n}\n\n/**\n * Predicate function to check if a file is uploading\n * @public\n */\nexport function isUploadingFile<TRoute extends AnyFileRoute = AnyFileRoute>(\n  file: AnyFile<TRoute>,\n): file is UploadingFile {\n  return file.status === \"uploading\";\n}\n\n/**\n * Predicate function to check if a file is failed\n * @public\n */\nexport function isFailedFile<TRoute extends AnyFileRoute = AnyFileRoute>(\n  file: AnyFile<TRoute>,\n): file is FailedFile<TRoute> {\n  return file.status === \"failed\";\n}\n\n/**\n * Predicate function to check if a file is uploaded\n * @public\n */\nexport function isUploadedFile<TRoute extends AnyFileRoute = AnyFileRoute>(\n  file: AnyFile<TRoute>,\n): file is UploadedFile<TRoute> {\n  return file.status === \"uploaded\";\n}\n\n/**\n * @internal\n */\nexport function makePendingFile(file: File): PendingFile {\n  return Object.assign(file, {\n    status: \"pending\" as const,\n    sent: 0,\n    key: null,\n    customId: null,\n  });\n}\n\n/**\n * Modifies a pending file to an uploading file in place\n * @internal\n */\nfunction transitionToUploading(\n  file: PendingFile,\n  rangeStart: number,\n): UploadingFile {\n  const uploadingFile = file as unknown as UploadingFile;\n  uploadingFile.sent = rangeStart;\n  uploadingFile.status = \"uploading\";\n  return uploadingFile;\n}\n\n/**\n * Modifies an uploading file to an uploaded file in place\n * @internal\n */\nfunction transitionToUploaded<TRoute extends AnyFileRoute>(\n  file: UploadingFile,\n  xhrResult: UploadPutResult,\n): UploadedFile<TRoute> {\n  const uploadedFile = file as unknown as UploadedFile<TRoute>;\n  uploadedFile.status = \"uploaded\";\n  uploadedFile.data = xhrResult.serverData;\n  uploadedFile.hash = xhrResult.fileHash;\n  uploadedFile.url = xhrResult.ufsUrl;\n  return uploadedFile;\n}\n\n/**\n * Modifies a pending or uploading file to a failed file in place\n * @internal\n */\nexport function transitionToFailed<TRoute extends AnyFileRoute>(\n  file: PendingFile | UploadingFile,\n  reason: UploadThingClientError<TRoute[\"$types\"][\"errorShape\"]>,\n): FailedFile<TRoute> {\n  const failedFile = file as unknown as FailedFile<TRoute>;\n  failedFile.status = \"failed\";\n  failedFile.reason = reason;\n  return failedFile;\n}\n\n/**\n * Event emitted when the presigned URLs have been retrieved from your server\n * @public\n */\nexport interface PresignedReceivedEvent<TRoute extends AnyFileRoute> {\n  type: \"presigned-received\";\n  /**\n   * All files that are being uploaded as part of this action.\n   */\n  files: AnyFile<TRoute>[];\n}\n\n/**\n * Event emitted when a file starts uploading\n * @public\n */\nexport interface UploadStartedEvent<TRoute extends AnyFileRoute> {\n  type: \"upload-started\";\n  /**\n   * The file that started uploading.\n   */\n  file: UploadingFile;\n  /**\n   * All files that are being uploaded as part of this action.\n   */\n  files: AnyFile<TRoute>[];\n}\n\n/**\n * Event emitted when a file is uploading and received a progress update\n * @public\n */\nexport interface UploadProgressEvent<TRoute extends AnyFileRoute> {\n  type: \"upload-progress\";\n  /**\n   * The file that is currently uploading and received a progress update.\n   */\n  file: UploadingFile;\n  /**\n   * All files that are being uploaded as part of this action.\n   */\n  files: AnyFile<TRoute>[];\n}\n\n/**\n * Event emitted when a file has finished uploading\n * @public\n */\nexport interface UploadCompletedEvent<TRoute extends AnyFileRoute> {\n  type: \"upload-completed\";\n  /**\n   * The file that finished uploading.\n   */\n  file: UploadedFile<TRoute>;\n  /**\n   * All files that are being uploaded as part of this action.\n   */\n  files: AnyFile<TRoute>[];\n}\n\n/**\n * Event emitted when a file failed to upload\n * @public\n */\nexport interface UploadFailedEvent<TRoute extends AnyFileRoute> {\n  type: \"upload-failed\";\n  /**\n   * The file that failed to upload.\n   */\n  file: FailedFile<TRoute>;\n  /**\n   * All files that are being uploaded as part of this action.\n   */\n  files: AnyFile<TRoute>[];\n}\n\nexport interface UploadAbortedEvent<TRoute extends AnyFileRoute> {\n  type: \"upload-aborted\";\n  files: AnyFile<TRoute>[];\n}\n\n/**\n * Event emitted throughout the upload process\n * @public\n */\nexport type UploadEvent<TRoute extends AnyFileRoute> =\n  | PresignedReceivedEvent<TRoute>\n  | UploadStartedEvent<TRoute>\n  | UploadProgressEvent<TRoute>\n  | UploadCompletedEvent<TRoute>\n  | UploadFailedEvent<TRoute>\n  | UploadAbortedEvent<TRoute>;\n\nexport interface UploadFileOptions<TRoute extends AnyFileRoute> {\n  file: PendingFile;\n  files: AnyFile<TRoute>[];\n  input: TRoute[\"$types\"][\"input\"];\n  onEvent: (event: UploadEvent<TRoute>) => void;\n  traceHeaders: TraceHeaders;\n\n  XHRImpl: new () => XMLHttpRequest;\n}\n\n/**\n * Upload a file to the storage provider\n * Throughout the upload, the file's status and progress will be updated\n * @remarks This function never rejects\n * @internal\n */\nexport function uploadFile<TRoute extends AnyFileRoute>(\n  url: string,\n  { file, files, XHRImpl, ...options }: UploadFileOptions<TRoute>,\n): Micro.Micro<UploadedFile<TRoute> | FailedFile<TRoute>, never, FetchContext> {\n  return fetchEff(url, { method: \"HEAD\", headers: options.traceHeaders }).pipe(\n    Micro.map(({ headers }) =>\n      Number.parseInt(headers.get(\"x-ut-range-start\") ?? \"0\"),\n    ),\n    Micro.map((rangeStart) => transitionToUploading(file, rangeStart)),\n    Micro.tap((uploadingFile) => {\n      options.onEvent({\n        type: \"upload-started\",\n        file: uploadingFile,\n        files,\n      });\n    }),\n    Micro.flatMap((uploadingFile) =>\n      Micro.async<UploadedFile<TRoute>, XHRError | UTStorageError>((resume) => {\n        const xhr = new XHRImpl();\n        xhr.open(\"PUT\", url, true);\n\n        const rangeStart = uploadingFile.sent;\n        xhr.setRequestHeader(\"Range\", `bytes=${rangeStart}-`);\n        xhr.setRequestHeader(\"x-uploadthing-version\", version);\n        xhr.setRequestHeader(\"b3\", options.traceHeaders.b3);\n        xhr.setRequestHeader(\"traceparent\", options.traceHeaders.traceparent);\n        xhr.responseType = \"json\";\n\n        xhr.upload.addEventListener(\"progress\", (ev) => {\n          uploadingFile.sent = rangeStart + ev.loaded;\n          options.onEvent({\n            type: \"upload-progress\",\n            file: uploadingFile,\n            files,\n          });\n        });\n        xhr.addEventListener(\"load\", () => {\n          if (\n            xhr.status > 299 ||\n            Predicate.hasProperty(xhr.response, \"error\")\n          ) {\n            resume(\n              new UTStorageError({\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                message: String(xhr.response.error),\n                response: xhr.response,\n              }),\n            );\n          } else {\n            const uploadedFile = transitionToUploaded<TRoute>(\n              uploadingFile,\n              xhr.response as UploadPutResult,\n            );\n            options.onEvent({\n              type: \"upload-completed\",\n              file: uploadedFile,\n              files,\n            });\n            resume(Micro.succeed(uploadedFile));\n          }\n        });\n        xhr.addEventListener(\"error\", () => {\n          resume(\n            new XHRError({\n              message: `XHR failed ${xhr.status} ${xhr.statusText}`,\n              xhr: xhr,\n            }),\n          );\n        });\n\n        const formData = new FormData();\n        /**\n         * iOS/React Native FormData handling requires special attention:\n         *\n         * Issue: In React Native, iOS crashes with \"attempt to insert nil object\" when appending File directly\n         * to FormData. This happens because iOS tries to create NSDictionary from the file object and expects\n         * specific structure {uri, type, name}.\n         *\n         *\n         * Note: Don't try to use Blob or modify File object - iOS specifically needs plain object\n         * with these properties to create valid NSDictionary.\n         */\n        if (\"uri\" in file) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          formData.append(\"file\", {\n            uri: file.uri as string,\n            type: file.type,\n            name: file.name,\n            ...(rangeStart > 0 && { range: rangeStart }),\n          } as any);\n        } else {\n          formData.append(\n            \"file\",\n            rangeStart > 0 ? file.slice(rangeStart) : file,\n          );\n        }\n        xhr.send(formData);\n\n        return Micro.sync(() => xhr.abort());\n      }),\n    ),\n    Micro.catchAll((error) => {\n      const failedFile = transitionToFailed<TRoute>(file, error);\n      options.onEvent({\n        type: \"upload-failed\",\n        file: failedFile,\n        files,\n      });\n      return Micro.succeed(failedFile);\n    }),\n  );\n}\n\nexport interface RequestPresignedUrlsOptions<\n  TRouter extends AnyFileRouter,\n  TEndpoint extends keyof TRouter,\n> {\n  /**\n   * The URL to your UploadThing server endpoint\n   * @example URL { https://www.example.com/api/uploadthing }\n   */\n  url: URL;\n  /**\n   * The slug to your UploadThing FileRoute\n   * @example \"imageUploader\"\n   */\n  endpoint: TEndpoint;\n  /**\n   * The files to request presigned URLs for\n   */\n  files: File[];\n  /**\n   * The route input for the endpoint\n   */\n  input?: TRouter[TEndpoint][\"$types\"][\"input\"];\n  /**\n   * Custom headers to send with the request\n   * @example { Authorization: \"Bearer 123\" }\n   */\n  headers?: HeadersInit | LazyArg<MaybePromise<HeadersInit>> | undefined;\n  /**\n   * Custom trace headers to send with the request\n   */\n  traceHeaders: TraceHeaders;\n  /**\n   * The uploadthing package that is making this request, used to identify the client in the server logs\n   * @example \"@uploadthing/react\"\n   */\n  package?: string | undefined;\n}\n\n/**\n * Request presigned URLs from your server for a set of files\n * @internal\n */\nexport function requestPresignedUrls<\n  TRouter extends AnyFileRouter,\n  TEndpoint extends keyof TRouter,\n>(\n  options: RequestPresignedUrlsOptions<TRouter, TEndpoint>,\n): Micro.Micro<\n  ReadonlyArray<NewPresignedUrl>,\n  UTServerError<TRouter[TEndpoint][\"$types\"][\"errorShape\"]>,\n  FetchContext\n> {\n  const reportEventToUT = createUTReporter({\n    endpoint: String(options.endpoint),\n    package: options.package,\n    url: options.url,\n    headers: options.headers,\n    traceHeaders: options.traceHeaders,\n  });\n\n  return reportEventToUT(\"upload\", {\n    input: options.input,\n    files: options.files.map((f) => ({\n      name: f.name,\n      size: f.size,\n      type: f.type,\n      lastModified: f.lastModified,\n    })),\n  }).pipe(\n    Micro.mapError(\n      (error) =>\n        new UTServerError({\n          message: error.message,\n          cause: error,\n          data: error.data,\n        }),\n    ),\n  );\n}\n\nexport interface UploadFilesOptions<TRoute extends AnyFileRoute> {\n  url: URL;\n  files: File[];\n  input?: TRoute[\"$types\"][\"input\"];\n  onEvent: (event: UploadEvent<TRoute>) => void;\n  headers?: HeadersInit | LazyArg<MaybePromise<HeadersInit>> | undefined;\n  package?: string | undefined;\n  signal?: AbortSignal | undefined;\n}\n\n/**\n * Upload a set of files to the storage provider\n * @internal\n */\nexport function uploadFiles<\n  TRouter extends AnyFileRouter,\n  TEndpoint extends keyof TRouter,\n>(endpoint: TEndpoint, options: UploadFilesOptions<TRouter[TEndpoint]>) {\n  const pendingFiles = options.files.map(makePendingFile);\n  const traceHeaders = generateTraceHeaders();\n  return requestPresignedUrls({\n    endpoint: endpoint,\n    files: options.files,\n    url: options.url,\n    input: options.input,\n    headers: options.headers,\n    package: options.package,\n    traceHeaders,\n  }).pipe(\n    Micro.map(Arr.zip(pendingFiles)),\n    Micro.tap((pairs) => {\n      for (const [presigned, file] of pairs) {\n        file.key = presigned.key;\n        file.customId = presigned.customId;\n      }\n      options.onEvent({\n        type: \"presigned-received\",\n        files: pendingFiles,\n      });\n    }),\n    Micro.flatMap((pairs) =>\n      Micro.forEach(\n        pairs,\n        ([presigned, file]) =>\n          uploadFile(presigned.url, {\n            file,\n            files: pendingFiles,\n            input: options.input,\n            onEvent: options.onEvent,\n            XHRImpl: globalThis.XMLHttpRequest,\n            traceHeaders,\n          }),\n        { concurrency: 6 },\n      ),\n    ),\n  );\n}\n","import * as Arr from \"effect/Array\";\nimport * as Micro from \"effect/Micro\";\n\nimport type { FetchEsque } from \"@uploadthing/shared\";\nimport {\n  createIdentityProxy,\n  FetchContext,\n  resolveMaybeUrlArg,\n  UploadAbortedError,\n  UploadPausedError,\n} from \"@uploadthing/shared\";\n\nimport * as pkgJson from \"../package.json\";\nimport type {\n  AnyFile,\n  FailedFile,\n  PendingFile,\n  UploadedFile,\n  UploadFilesOptions,\n  UploadingFile,\n} from \"./_internal/client-future\";\nimport {\n  makePendingFile,\n  requestPresignedUrls,\n  transitionToFailed,\n  uploadFile,\n} from \"./_internal/client-future\";\nimport type { Deferred } from \"./_internal/deferred\";\nimport { createDeferred } from \"./_internal/deferred\";\nimport { generateTraceHeaders } from \"./_internal/random-hex\";\nimport type {\n  EndpointArg,\n  FileRouter,\n  GenerateUploaderOptions,\n  inferEndpointInput,\n  NewPresignedUrl,\n  RouteRegistry,\n} from \"./types\";\n\nexport const version = pkgJson.version;\n\nexport {\n  /** @public */\n  generateClientDropzoneAccept,\n  /** @public */\n  generateMimeTypes,\n  /** @public */\n  generatePermittedFileTypes,\n  /** @public */\n  UploadAbortedError,\n  /** @public */\n  UploadPausedError,\n} from \"@uploadthing/shared\";\n\nexport * from \"./_internal/client-future\";\n\n/**\n * Generate a typed uploader for a given FileRouter\n * @public\n * @remarks This API is not covered by semver\n */\nexport const future_genUploader = <TRouter extends FileRouter>(\n  initOpts?: GenerateUploaderOptions,\n) => {\n  const routeRegistry = createIdentityProxy<RouteRegistry<TRouter>>();\n\n  const controllableUpload = async <TEndpoint extends keyof TRouter>(\n    slug: EndpointArg<TRouter, TEndpoint>,\n    options: Omit<\n      UploadFilesOptions<TRouter[TEndpoint]>,\n      keyof GenerateUploaderOptions\n    >,\n  ) => {\n    const endpoint = typeof slug === \"function\" ? slug(routeRegistry) : slug;\n    const fetchFn: FetchEsque = initOpts?.fetch ?? window.fetch;\n\n    const traceHeaders = generateTraceHeaders();\n    const pExit = await requestPresignedUrls({\n      endpoint: String(endpoint),\n      files: options.files,\n      url: resolveMaybeUrlArg(initOpts?.url),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      input: (options as any).input as inferEndpointInput<TRouter[TEndpoint]>,\n      headers: options.headers,\n      traceHeaders,\n    }).pipe(Micro.provideService(FetchContext, fetchFn), (effect) =>\n      Micro.runPromiseExit(\n        effect,\n        options.signal && { signal: options.signal },\n      ),\n    );\n    if (pExit._tag === \"Failure\") throw Micro.causeSquash(pExit.cause);\n    const presigneds = pExit.value;\n    const pendingFiles = options.files.map(makePendingFile);\n\n    options.onEvent({\n      type: \"presigned-received\",\n      files: pendingFiles,\n    });\n\n    const uploads = new Map<\n      File,\n      {\n        presigned: NewPresignedUrl;\n        deferred: Deferred<AnyFile<TRouter[TEndpoint]>>;\n      }\n    >();\n\n    const uploadEffect = (file: PendingFile, presigned: NewPresignedUrl) =>\n      uploadFile(presigned.url, {\n        file,\n        files: pendingFiles,\n        input: options.input,\n        onEvent: options.onEvent,\n        traceHeaders,\n        XHRImpl: globalThis.XMLHttpRequest,\n      }).pipe(Micro.provideService(FetchContext, fetchFn));\n\n    for (const [presigned, file] of Arr.zip(presigneds, pendingFiles)) {\n      file.key = presigned.key;\n      file.customId = presigned.customId;\n\n      const deferred = createDeferred<AnyFile<TRouter[TEndpoint]>>();\n      uploads.set(file, { presigned, deferred });\n\n      void Micro.runPromiseExit(uploadEffect(file, presigned), {\n        signal: deferred.ac.signal,\n      })\n        .then((result) => {\n          if (result._tag === \"Success\") {\n            return deferred.resolve(result.value);\n          } else if (result.cause._tag === \"Interrupt\") {\n            throw new UploadPausedError();\n          }\n          throw Micro.causeSquash(result.cause);\n        })\n        .catch((err) => {\n          if (err instanceof UploadPausedError) return;\n          deferred.reject(err);\n        });\n    }\n\n    /**\n     * Pause an ongoing upload\n     * @param file The file upload you want to pause. Can be omitted to pause all files\n     */\n    const pauseUpload = (file?: File) => {\n      const files = Arr.ensure(file ?? options.files);\n      for (const file of files) {\n        const upload = uploads.get(file);\n        if (!upload) return;\n\n        if (upload.deferred.ac.signal.aborted) {\n          // Noop if it's already paused\n          return;\n        }\n\n        upload.deferred.ac.abort();\n      }\n    };\n\n    /**\n     * Abort an upload\n     * @param file The file upload you want to abort. Can be omitted to abort all files\n     */\n    const abortUpload = (file?: File) => {\n      const files = Arr.ensure(file ?? options.files);\n      for (const file of files) {\n        const upload = uploads.get(file);\n        if (!upload) throw \"No upload found\";\n\n        if (upload.deferred.ac.signal.aborted === false) {\n          upload.deferred.ac.abort();\n          const failedFile = transitionToFailed(\n            file as UploadingFile | PendingFile,\n            new UploadAbortedError(),\n          );\n          upload.deferred.resolve(failedFile);\n        }\n      }\n\n      options.onEvent({\n        type: \"upload-aborted\",\n        // transitionToFailed mutates inline so this is fine\n        files: files as FailedFile<TRouter[TEndpoint]>[],\n      });\n    };\n\n    options.signal?.addEventListener(\"abort\", () => {\n      abortUpload();\n    });\n\n    /**\n     * Resume a paused upload\n     * @param file The file upload you want to resume. Can be omitted to resume all files\n     */\n    const resumeUpload = (file?: File) => {\n      const files = Arr.ensure(file ?? options.files);\n      for (const file of files) {\n        const upload = uploads.get(file);\n        if (!upload) throw \"No upload found\";\n\n        upload.deferred.ac = new AbortController();\n        void Micro.runPromiseExit(\n          uploadEffect(file as PendingFile, upload.presigned),\n          {\n            signal: upload.deferred.ac.signal,\n          },\n        )\n          .then((result) => {\n            if (result._tag === \"Success\") {\n              return upload.deferred.resolve(result.value);\n            } else if (result.cause._tag === \"Interrupt\") {\n              throw new UploadPausedError();\n            }\n            throw Micro.causeSquash(result.cause);\n          })\n          .catch((err) => {\n            if (err instanceof UploadPausedError) return;\n            upload.deferred.reject(err);\n          });\n      }\n    };\n\n    /**\n     * Wait for an upload to complete\n     * @param file The file upload you want to wait for. Can be omitted to wait for all files\n     */\n    const done = async <T extends AnyFile<TRouter[TEndpoint]> | void = void>(\n      file?: T,\n    ): Promise<\n      T extends AnyFile<TRouter[TEndpoint]>\n        ? UploadedFile<TRouter[TEndpoint]> | FailedFile<TRouter[TEndpoint]>\n        : (UploadedFile<TRouter[TEndpoint]> | FailedFile<TRouter[TEndpoint]>)[]\n    > => {\n      const promises = [];\n\n      const files = Arr.ensure(file ?? options.files);\n      for (const file of files) {\n        const upload = uploads.get(file);\n        if (!upload) throw \"No upload found\";\n\n        promises.push(upload.deferred.promise);\n      }\n\n      const results = await Promise.all(promises);\n      return (file ? results[0] : results) as never;\n    };\n\n    return { pauseUpload, abortUpload, resumeUpload, done };\n  };\n\n  const uploadFiles = <TEndpoint extends keyof TRouter>(\n    slug: EndpointArg<TRouter, TEndpoint>,\n    opts: Omit<\n      UploadFilesOptions<TRouter[TEndpoint]>,\n      keyof GenerateUploaderOptions\n    >,\n  ) => controllableUpload(slug, opts).then((_) => _.done());\n\n  return {\n    uploadFiles,\n    createUpload: controllableUpload,\n    /**\n     * Identity object that can be used instead of raw strings\n     * that allows \"Go to definition\" in your IDE to bring you\n     * to the backend definition of a route.\n     */\n    routeRegistry,\n  };\n};\n"],"mappings":"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"}